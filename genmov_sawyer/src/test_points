#!/usr/bin/env python3
import rospy
from sensor_msgs.msg import JointState
from markers import *
from lab4functions import *
import matplotlib.pyplot as plt

if __name__ == '__main__':

    # Initialize the node
    rospy.init_node("testControlPoints")
    print('starting motion ... ')
    # Publisher: publish to the joint_states topic
    pub = rospy.Publisher('joint_states', JointState, queue_size=10)
 
    # Markers for the current and desired positions
    bmarker_current  = BallMarker(color['RED'])
    bmarker_desired = BallMarker(color['GREEN'])
    bmarker_desired_elbow = BallMarker(color['BLUE'])

     # Joint names
    jnames = ("head_pan", "right_j0", "right_j1", "right_j2", "right_j3","right_j4", "right_j5", "right_j6")

    # Gets points
    # poner ruta correspondiente
    hand_points = np.loadtxt('/home/andres/proy_ws/src/GenMov/genmov_sawyer/src/Sawyer_right_hand_points.txt', dtype=float) 
    elbow_points = np.loadtxt('/home/andres/proy_ws/src/GenMov/genmov_sawyer/src/Sawyer_right_forearm_points.txt', dtype=float) 

    # Desired initial position
    it=0
    xd = hand_points[it]
    xd_elbow = elbow_points[it]

    # Initial configuration
    q0 = np.array([0, 1.06, 0, 0.54, 0, 0.0, 0.0])

    # Resulting initial position (end effector with respect to the base link)
    T = fkine_sawyer(q0)
    x0 = T[0:3,3]

    # Red marker shows the achieved position
    bmarker_current.xyz(x0)
    # Green marker shows the desired position
    bmarker_desired.xyz(xd)
    bmarker_desired_elbow.xyz(xd_elbow)

    # Initializing for plotting
    actual=[]
    actual.append(x0.tolist())
    x_actual=[]; y_actual=[]; z_actual=[]
    x_deseado=[]; y_deseado=[]; z_deseado=[]
    x_error=[]; y_error=[]; z_error=[]
    q_plot=[]

    # Instance of the JointState message
    jstate = JointState()
    # Values of the message
    jstate.header.stamp = rospy.Time.now()
    jstate.name = jnames

    # Add the head joint value (with value 0) to the joints
    q0[3]=-q0[3]
    q_wh=np.append(0.0,q0)
    jstate.position = q_wh
    
    # Frequency (in Hz) and control period 
    freq = 200
    dt = 1.0/freq
    rate = rospy.Rate(freq)

    # Initial joint configuration
    q = copy(q0)
    # k de control
    k = 0.8; k2 = 0.8

    # Main loop
    while not rospy.is_shutdown():
        # Current time (needed for ROS)
        jstate.header.stamp = rospy.Time.now()
        
        # Kinematic control law for position1
        # Invert due to model
        q[3]=-q[3]

        # Transform and position
        T = fkine_sawyer(q)
        x = T[0:3,3]
        T2 = fkine_sawyer_codo(q)
        x_elbow = T2[0:3,3]
            

        # Error
        error = x - xd
        derror = -k*error
        error_elbow = x_elbow - xd_elbow
        derror_elbow = -k2*error_elbow

        # Add 'actual'
        x_actual.append(x[0].tolist()); y_actual.append(x[1].tolist()); z_actual.append(x[2].tolist())
        x_deseado.append(xd[0].tolist()); y_deseado.append(xd[1].tolist()); z_deseado.append(xd[2].tolist())    
        x_error.append(error[0].tolist()); y_error.append(error[1].tolist()); z_error.append(error[2].tolist())
        q_plot.append(q.tolist())
        
        # Jacobian of robot and until elbow
        Jacobian=jacobian_sawyer(q)
        Jacobian_elbow=jacobian_sawyer_codo(q)
        #print((Jacobian@Jacobian.T).shape )
        if np.linalg.det(Jacobian@Jacobian.T ) < 0.0001:
            print("singularidad !")
            break

        # Moore-Penrose Pseudoinverse 
        pseudoinverse = np.linalg.pinv(Jacobian)
        P1 = np.eye(7) - pseudoinverse@Jacobian
        pseudoinverse_elbow = np.linalg.pinv(Jacobian_elbow@P1)

        # Control Law
        dq = pseudoinverse.dot(derror) + pseudoinverse_elbow.dot(derror_elbow-Jacobian_elbow@pseudoinverse@derror)
        #dq = np.linalg.pinv(Jacobian).dot(derror)
        q = q + dt*dq
         
        
        # Publish the message
        q[3]=-q[3]
        q_wh=np.append(0.0,q)
        jstate.position = q_wh
        
        pub.publish(jstate)
        bmarker_desired.xyz(xd)
        bmarker_current.xyz(x)
        bmarker_desired_elbow.xyz(xd_elbow)

        if (np.linalg.norm(error) < 0.01): #se quitó un 0 para que sea más rápido
            print("Iteración ",it," completa")
            if it==len(hand_points)-1: break
            it+=1
            xd = hand_points[it]
            xd_elbow = elbow_points[it]

        # Wait for the next iteration
        rate.sleep()
    print('ending motion ...')
    
    
    iteracion = np.linspace(0, len(x_actual)-1, len(x_actual))
    x_error = [abs(x) for x in x_error]
    y_error = [abs(x) for x in y_error]
    z_error = [abs(x) for x in z_error]

    fig, axs = plt.subplots(3, 1, figsize=(10, 15))
    # Subplot for X axis
    axs[0].plot(iteracion, x_actual, label='X actual')
    axs[0].plot(iteracion, x_deseado, label='X deseado')
    axs[0].plot(iteracion, x_error, label='Error absoluto en X', color='red')
    axs[0].grid(True)
    axs[0].axhline(0, color='black', linewidth=0.7)
    axs[0].set_title('X actual vs X deseado')
    axs[0].set_xlabel('Iteration')
    axs[0].set_ylabel('X axis')
    axs[0].legend()

    # Subplot for Y axis
    axs[1].plot(iteracion, y_actual, label='Y actual')
    axs[1].plot(iteracion, y_deseado, label='Y deseado')
    axs[1].plot(iteracion, y_error, label='Error absoluto en Y', color='red')
    axs[1].grid(True)
    axs[1].axhline(0, color='black', linewidth=0.7)
    axs[1].set_title('Y actual vs Y deseado')
    axs[1].set_xlabel('Iteration')
    axs[1].set_ylabel('Y axis')
    axs[1].legend()

    # Subplot for Z axis
    axs[2].plot(iteracion, z_actual, label='Z actual')
    axs[2].plot(iteracion, z_deseado, label='Z deseado')
    axs[2].plot(iteracion, z_error, label='Error absoluto en Z', color='red')
    axs[2].grid(True)
    axs[2].axhline(0, color='black', linewidth=0.7)
    axs[2].set_title('Z actual vs Z deseado')
    axs[2].set_xlabel('Iteration')
    axs[2].set_ylabel('Z axis')
    axs[2].legend()


    plt.figure(2)
    plt.plot(iteracion,q_plot, label=['q0', 'q1', 'q2', 'q3', 'q4', 'q5', 'q6'])
    plt.title('q en el tiempo')
    plt.xlabel('Iteration')
    plt.ylabel('Ángulo (rad)')
    plt.legend()

    fig = plt.figure(3)
    ax = fig.add_subplot(111, projection='3d')
    ax.plot(x_actual, y_actual, z_actual, label='Trayectoria en 3D')
    ax.plot(x_deseado,y_deseado, z_deseado)
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    ax.legend()


    
    # Display plots
    plt.show()
    plt.show()
    plt.show()
    #plt.show()
    #plt.show()

    